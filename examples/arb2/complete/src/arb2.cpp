// /////////////////////////////////////////////////////////////////////////
// C++ code automatically generated by hif2sc
// Part of HIFSuite - Version 
// Site: www.hifsuite.com - Contact: hifsuite@edalab.it
//
// HIFSuite copyright: EDALab s.r.l. - Networked Embedded Systems
// Site: www.edalab.it - Contact: info@edalab.it
// /////////////////////////////////////////////////////////////////////////


#include "../inc/arb2.hpp"



arb2::arb2() :
    hif_fault_node(muffin::hif_next_instance_counter(), 8ULL),
    req2_old(false),
    req1_old(false),
    rst_old(false),
    clk_old(false),
    hif_a2t_data(
    false,
    false,
    false,
    false,
    false,
    false),
    gnt1_out_sig(false),
    gnt1_out_sig_sig_var(false),
    state(false),
    gnt1_out_sig_new(false),
    state_new(false),
    process_in_queue(false),
    flag_process_executed(false),
    flag_pos_clk(false),
    flag_pos_rst(false),
    flag_process_0_executed(false),
    flag_state(false),
    flag_req1(false),
    flag_req2(false),
    flag_gnt1_out_sig(false)
{
    if (hif_fault_list_root != nullptr)
    {
        hif_fault_list_root->prev = &hif_fault_node;
        hif_fault_node.next = hif_fault_list_root;
    }
    hif_fault_list_root = &hif_fault_node;
}


arb2::~arb2()
{}


void arb2::process()
{
    if (hif_a2t_data.rst)
    {
        state_new = muffin::inject( hif_fault_node.instance, 0ULL, 1ULL, false 
            );
    }
    else
    {
        state_new = muffin::inject( hif_fault_node.instance, 1ULL, 1ULL, gnt1_out_sig_sig_var
             );
    }
}


void arb2::process_0()
{
    if (state)
    {
        gnt1_out_sig_sig_var = muffin::inject( hif_fault_node.instance, 2ULL, 1ULL,
                 !hif_a2t_data.req2 && hif_a2t_data.req1 );
        gnt1_out_sig_new = muffin::inject( hif_fault_node.instance, 3ULL, 1ULL,
                 gnt1_out_sig_sig_var );
        hif_a2t_data.gnt2 = muffin::inject( hif_fault_node.instance, 4ULL, 1ULL,
                 hif_a2t_data.req2 );
    }
    else
    {
        gnt1_out_sig_sig_var = muffin::inject( hif_fault_node.instance, 5ULL, 1ULL,
                 hif_a2t_data.req1 );
        gnt1_out_sig_new = muffin::inject( hif_fault_node.instance, 6ULL, 1ULL,
                 gnt1_out_sig_sig_var );
        hif_a2t_data.gnt2 = muffin::inject( hif_fault_node.instance, 7ULL, 1ULL,
                 !hif_a2t_data.req1 && hif_a2t_data.req2 );
    }
}


void arb2::gnt1_update_process()
{
    hif_a2t_data.gnt1 = gnt1_out_sig_sig_var;
}


void arb2::update_input_queue( bool synch_phase )
{
    process_in_queue = false;
    if (hif_a2t_data.clk != clk_old)
    {
        clk_old = hif_a2t_data.clk;
        if (hif_a2t_data.clk == true)
        {
            flag_pos_clk = true;
        }
        else
        {
            flag_pos_clk = false;
        }
        process_in_queue = true;
    }
    else
    {
        flag_pos_clk = false;
    }
    if (hif_a2t_data.rst != rst_old)
    {
        rst_old = hif_a2t_data.rst;
        if (hif_a2t_data.rst == true)
        {
            flag_pos_rst = true;
        }
        else
        {
            flag_pos_rst = false;
        }
        process_in_queue = true;
    }
    else
    {
        flag_pos_rst = false;
    }
    if (hif_a2t_data.req1 != req1_old)
    {
        req1_old = hif_a2t_data.req1;
        flag_req1 = true;
        process_in_queue = true;
    }
    else
    {
        flag_req1 = false;
    }
    if (hif_a2t_data.req2 != req2_old)
    {
        req2_old = hif_a2t_data.req2;
        flag_req2 = true;
        process_in_queue = true;
    }
    else
    {
        flag_req2 = false;
    }
}


void arb2::update_event_queue()
{
    process_in_queue = false;
    if (flag_process_0_executed && gnt1_out_sig != gnt1_out_sig_new)
    {
        gnt1_out_sig = gnt1_out_sig_new;
        flag_gnt1_out_sig = true;
        process_in_queue = true;
    }
    else
    {
        flag_gnt1_out_sig = false;
    }
    if (flag_process_executed && state != state_new)
    {
        state = state_new;
        flag_state = true;
        process_in_queue = true;
    }
    else
    {
        flag_state = false;
    }
}


void arb2::flag_elaboration()
{
    flag_process_executed = false;
    if (flag_pos_clk || flag_pos_rst)
    {
        process();
        flag_process_executed = true;
    }
    flag_process_0_executed = false;
    if (flag_state || (flag_req1 || flag_req2))
    {
        process_0();
        flag_process_0_executed = true;
    }
    if (flag_gnt1_out_sig)
    {
        gnt1_update_process();
    }
}


void arb2::synch_elaboration()
{
    update_input_queue( true );
    flag_elaboration();
    flag_pos_clk = false;
    flag_pos_rst = false;
    flag_req1 = false;
    flag_req2 = false;
    update_event_queue();
}


void arb2::simulate( arb2_iostruct * io_exchange, int32_t & cycles_number )
{
    hif_a2t_data.clk = io_exchange->clk;
    hif_a2t_data.rst = io_exchange->rst;
    hif_a2t_data.req1 = io_exchange->req1;
    hif_a2t_data.req2 = io_exchange->req2;
    cycles_number = cycles_number + 1L;
    synch_elaboration();
    while (process_in_queue)
    {
        flag_elaboration();
        update_event_queue();
    }
    io_exchange->gnt1 = hif_a2t_data.gnt1;
    io_exchange->gnt2 = hif_a2t_data.gnt2;
}


void arb2::start_of_simulation()
{
    process();
    flag_process_executed = true;
    process_0();
    flag_process_0_executed = true;
    gnt1_update_process();
    update_event_queue();
}


void arb2::initialize()
{
    start_of_simulation();
}


void arb2::finalize()
{
}




