// /////////////////////////////////////////////////////////////////////////
// C++ code automatically generated by hif2sc
// Part of HIFSuite - Version 
// Site: www.hifsuite.com - Contact: hifsuite@edalab.it
//
// HIFSuite copyright: EDALab s.r.l. - Networked Embedded Systems
// Site: www.edalab.it - Contact: info@edalab.it
// /////////////////////////////////////////////////////////////////////////


#include "../inc/test.hpp"



test::test() :
    hif_fault_node(muffin::hif_next_instance_counter(), 0ULL),
    b_3_old(false),
    a_3_old(false),
    b_2_old(false),
    a_2_old(false),
    b_1_old(false),
    a_1_old(false),
    clock_old(false),
    hif_a2t_data(
    false,
    false,
    false,
    false,
    false,
    false,
    false,
    false,
    false,
    false),
    spec_sbm0(),
    spec_sbm1(),
    spec_sbm2(),
    process_in_queue(false),
    _bindings_completed(perform_bindings())
{
    if (hif_fault_list_root != nullptr)
    {
        hif_fault_list_root->prev = &hif_fault_node;
        hif_fault_node.next = hif_fault_list_root;
    }
    hif_fault_list_root = &hif_fault_node;
}


test::~test()
{}



bool test::perform_bindings()
{
    spec_sbm0.hif_a2t_data.clock = &hif_a2t_data.clock;
    spec_sbm0.hif_a2t_data.a_1 = &hif_a2t_data.a_1;
    spec_sbm0.hif_a2t_data.b_1 = &hif_a2t_data.b_1;
    spec_sbm0.hif_a2t_data.c_1 = &hif_a2t_data.c_1;
    spec_sbm1.hif_a2t_data.clock = &hif_a2t_data.clock;
    spec_sbm1.hif_a2t_data.a_2 = &hif_a2t_data.a_2;
    spec_sbm1.hif_a2t_data.b_2 = &hif_a2t_data.b_2;
    spec_sbm1.hif_a2t_data.c_2 = &hif_a2t_data.c_2;
    spec_sbm2.hif_a2t_data.clock = &hif_a2t_data.clock;
    spec_sbm2.hif_a2t_data.a_3 = &hif_a2t_data.a_3;
    spec_sbm2.hif_a2t_data.b_3 = &hif_a2t_data.b_3;
    spec_sbm2.hif_a2t_data.c_3 = &hif_a2t_data.c_3;
    return true;
}


void test::update_input_queue( bool synch_phase )
{
    process_in_queue = false;
    clock_old = hif_a2t_data.clock;
    a_1_old = hif_a2t_data.a_1;
    b_1_old = hif_a2t_data.b_1;
    a_2_old = hif_a2t_data.a_2;
    b_2_old = hif_a2t_data.b_2;
    a_3_old = hif_a2t_data.a_3;
    b_3_old = hif_a2t_data.b_3;
    if (synch_phase)
    {
        spec_sbm0.update_input_queue( true );
        spec_sbm1.update_input_queue( true );
        spec_sbm2.update_input_queue( true );
        process_in_queue = process_in_queue || (spec_sbm0.process_in_queue || (spec_sbm1.process_in_queue
             || spec_sbm2.process_in_queue));
    }
}


void test::update_event_queue()
{
    process_in_queue = false;
    spec_sbm0.update_event_queue();
    spec_sbm1.update_event_queue();
    spec_sbm2.update_event_queue();
    process_in_queue = process_in_queue || (spec_sbm0.process_in_queue || (spec_sbm1.process_in_queue
         || spec_sbm2.process_in_queue));
}


void test::flag_elaboration()
{
    if (spec_sbm0.process_in_queue)
    {
        spec_sbm0.flag_elaboration();
    }
    if (spec_sbm1.process_in_queue)
    {
        spec_sbm1.flag_elaboration();
    }
    if (spec_sbm2.process_in_queue)
    {
        spec_sbm2.flag_elaboration();
    }
}


void test::synch_elaboration()
{
    update_input_queue( true );
    flag_elaboration();
    update_event_queue();
}


void test::simulate( test_iostruct * io_exchange, int32_t & cycles_number )
{
    hif_a2t_data.clock = io_exchange->clock;
    hif_a2t_data.a_1 = io_exchange->a_1;
    hif_a2t_data.b_1 = io_exchange->b_1;
    hif_a2t_data.a_2 = io_exchange->a_2;
    hif_a2t_data.b_2 = io_exchange->b_2;
    hif_a2t_data.a_3 = io_exchange->a_3;
    hif_a2t_data.b_3 = io_exchange->b_3;
    cycles_number = cycles_number + 1L;
    synch_elaboration();
    while (process_in_queue)
    {
        flag_elaboration();
        update_event_queue();
    }
    io_exchange->c_1 = hif_a2t_data.c_1;
    io_exchange->c_2 = hif_a2t_data.c_2;
    io_exchange->c_3 = hif_a2t_data.c_3;
}


void test::start_of_simulation()
{
    update_event_queue();
}


void test::initialize()
{
    start_of_simulation();
    spec_sbm0.initialize();
    spec_sbm1.initialize();
    spec_sbm2.initialize();
}


void test::finalize()
{
}




